{"abi":[{"type":"function","name":"claimRewards","inputs":[{"name":"vault","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"collectToVault","inputs":[{"name":"vault","type":"address","internalType":"address"}],"outputs":[{"name":"amount0","type":"uint256","internalType":"uint256"},{"name":"amount1","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"currentTokenId","inputs":[{"name":"vault","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"exitPositionToVault","inputs":[{"name":"vault","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"gauge","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"nfpm","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"openInitialPosition","inputs":[{"name":"vault","type":"address","internalType":"address"},{"name":"tickLower","type":"int24","internalType":"int24"},{"name":"tickUpper","type":"int24","internalType":"int24"}],"outputs":[{"name":"tokenId","type":"uint256","internalType":"uint256"},{"name":"liquidity","type":"uint128","internalType":"uint128"}],"stateMutability":"nonpayable"},{"type":"function","name":"pool","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"rebalanceWithCaps","inputs":[{"name":"vault","type":"address","internalType":"address"},{"name":"tickLower","type":"int24","internalType":"int24"},{"name":"tickUpper","type":"int24","internalType":"int24"},{"name":"cap0","type":"uint256","internalType":"uint256"},{"name":"cap1","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"newLiquidity","type":"uint128","internalType":"uint128"}],"stateMutability":"nonpayable"},{"type":"function","name":"slot0","inputs":[],"outputs":[{"name":"sqrtPriceX96","type":"uint160","internalType":"uint160"},{"name":"tick","type":"int24","internalType":"int24"}],"stateMutability":"view"},{"type":"function","name":"stakePosition","inputs":[{"name":"vault","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"tickSpacing","inputs":[],"outputs":[{"name":"","type":"int24","internalType":"int24"}],"stateMutability":"view"},{"type":"function","name":"tokens","inputs":[],"outputs":[{"name":"token0","type":"address","internalType":"address"},{"name":"token1","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"unstakePosition","inputs":[{"name":"vault","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"claimRewards(address)":"ef5cfb8c","collectToVault(address)":"762100e7","currentTokenId(address)":"86ff5c4b","exitPositionToVault(address)":"b0217240","gauge()":"a6f19c84","nfpm()":"7303e913","openInitialPosition(address,int24,int24)":"109162ef","pool()":"16f0115b","rebalanceWithCaps(address,int24,int24,uint256,uint256)":"6783ac17","slot0()":"3850c7bd","stakePosition(address)":"e4010503","tickSpacing()":"d0c93a7c","tokens()":"9d63848a","unstakePosition(address)":"dcfc070b"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"collectToVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"currentTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"exitPositionToVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nfpm\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"openInitialPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint256\",\"name\":\"cap0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap1\",\"type\":\"uint256\"}],\"name\":\"rebalanceWithCaps\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"newLiquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slot0\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"stakePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tickSpacing\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"unstakePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"- The adapter is responsible for:     * Holding the LP NFT (position) for each vault.     * Pulling tokens from the vault when opening/rebalancing.     * Pushing tokens back to the vault when exiting or collecting. - The vault (ClientVault) is responsible for all higher-level risk logic:     * When to rebalance, what ranges to use, how much to allocate.     * Automation cooldowns, slippage limits, etc. - This interface must be implemented by each protocol-specific adapter.\",\"kind\":\"dev\",\"methods\":{\"claimRewards(address)\":{\"details\":\"Implementations that cannot deliver rewards directly to the vault MAY      route rewards through the adapter and then forward them to the vault.\",\"params\":{\"vault\":\"Vault address whose rewards will be claimed.\"}},\"collectToVault(address)\":{\"params\":{\"vault\":\"Vault address whose position fees will be collected.\"},\"returns\":{\"amount0\":\"Amount of token0 sent to the vault.\",\"amount1\":\"Amount of token1 sent to the vault.\"}},\"currentTokenId(address)\":{\"params\":{\"vault\":\"Vault address owning the position.\"}},\"exitPositionToVault(address)\":{\"details\":\"- Typical implementation:     * Collect fees.     * Decrease all liquidity, collect owed tokens.     * Burn the NFT.     * Transfer all token0/token1 balances held by the adapter for this position back to the vault. - If there is no position for the vault, this function SHOULD simply return.\",\"params\":{\"vault\":\"Vault address whose position will be closed.\"}},\"gauge()\":{\"details\":\"May be zero address if no staking is used.\"},\"openInitialPosition(address,int24,int24)\":{\"details\":\"- The adapter is expected to:     * Read token0/token1 balances from the vault.     * Transfer those tokens into the adapter.     * Mint an LP NFT and keep it under the adapter.     * Return any unused tokens back to the vault. - Implementations MAY assume the vault has `approve`d this adapter   to pull tokens through ERC-20 `transferFrom`.\",\"params\":{\"tickLower\":\"Lower bound of the price range.\",\"tickUpper\":\"Upper bound of the price range.\",\"vault\":\"Vault address on behalf of which the position is opened.\"},\"returns\":{\"liquidity\":\"Final liquidity amount for the minted position.\",\"tokenId\":\"Newly created LP NFT id.\"}},\"rebalanceWithCaps(address,int24,int24,uint256,uint256)\":{\"details\":\"- Typical implementation:     * Collect fees to the adapter.     * Decrease liquidity fully and collect owed tokens.     * Burn the old NFT.     * Optionally pull more token0/token1 from the vault up to (cap0, cap1).     * Mint a new position in the new range, returning unused tokens to the vault.\",\"params\":{\"cap0\":\"Maximum additional token0 to pull from the vault (0 = no limit / use all).\",\"cap1\":\"Maximum additional token1 to pull from the vault (0 = no limit / use all).\",\"tickLower\":\"New lower bound of the price range.\",\"tickUpper\":\"New upper bound of the price range.\",\"vault\":\"Vault address whose position will be rebalanced.\"},\"returns\":{\"newLiquidity\":\"Liquidity of the newly minted position.\"}},\"stakePosition(address)\":{\"details\":\"If `gauge()` is zero address, implementation MAY simply return.\",\"params\":{\"vault\":\"Vault address whose position will be staked.\"}},\"unstakePosition(address)\":{\"details\":\"If `gauge()` is zero address, implementation MAY simply return.\",\"params\":{\"vault\":\"Vault address whose position will be unstaked.\"}}},\"title\":\"IConcentratedLiquidityAdapter\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"claimRewards(address)\":{\"notice\":\"Claim staking rewards for a vault's position and forward them to the vault.\"},\"collectToVault(address)\":{\"notice\":\"Collect outstanding pool fees for a vault's position and push them to the vault.\"},\"currentTokenId(address)\":{\"notice\":\"Returns the current LP NFT id (if any) assigned to a given vault.\"},\"exitPositionToVault(address)\":{\"notice\":\"Exit the current position for a vault and return all tokens to the vault.\"},\"gauge()\":{\"notice\":\"Returns the gauge / staking contract address (if any).\"},\"nfpm()\":{\"notice\":\"Returns the Non-Fungible Position Manager address (NFT LP manager).\"},\"openInitialPosition(address,int24,int24)\":{\"notice\":\"Open an initial concentrated-liquidity position for a vault.\"},\"pool()\":{\"notice\":\"Returns the underlying CL pool address.\"},\"rebalanceWithCaps(address,int24,int24,uint256,uint256)\":{\"notice\":\"Rebalance an existing position for a vault with upper caps for additional capital.\"},\"slot0()\":{\"notice\":\"Returns current pool price info (sqrtPriceX96, tick).\"},\"stakePosition(address)\":{\"notice\":\"Stake the vault's LP NFT into the gauge / MasterChef (if any).\"},\"tickSpacing()\":{\"notice\":\"Returns the pool tick spacing.\"},\"tokens()\":{\"notice\":\"Returns the underlying token pair (token0, token1) for the pool.\"},\"unstakePosition(address)\":{\"notice\":\"Unstake the LP NFT from the gauge / MasterChef (if any).\"}},\"notice\":\"Generic interface for a concentrated-liquidity adapter (Uniswap v3, Pancake v3, Aerodrome Slipstream, etc.).\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/interfaces/IConcentratedLiquidityAdapter.sol\":\"IConcentratedLiquidityAdapter\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":@openzeppelin/=lib/openzeppelin-contracts/\",\":@uniswap/swap-router-contracts/=lib/swap-router-contracts/\",\":@uniswap/v3-core/=lib/v3-core/\",\":@uniswap/v3-periphery/=lib/v3-periphery/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":swap-router-contracts/=lib/swap-router-contracts/contracts/\",\":v3-core/=lib/v3-core/\",\":v3-periphery/=lib/v3-periphery/contracts/\"],\"viaIR\":true},\"sources\":{\"src/interfaces/IConcentratedLiquidityAdapter.sol\":{\"keccak256\":\"0x11a9be76965d03cfde84421a01e9525e68beeb0eacb091167e1e16a7408e1924\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://34c299c8582cff6c0bd94366070a269b52f00a8cbe650a862b307d41490a39bf\",\"dweb:/ipfs/QmQnza3LZKZRpk85tgdYyUvhJryxm2yFJGkPtaHkRCjDMY\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.30+commit.73712a01"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"vault","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"claimRewards"},{"inputs":[{"internalType":"address","name":"vault","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"collectToVault","outputs":[{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"vault","type":"address"}],"stateMutability":"view","type":"function","name":"currentTokenId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"vault","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"exitPositionToVault"},{"inputs":[],"stateMutability":"view","type":"function","name":"gauge","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"nfpm","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[{"internalType":"address","name":"vault","type":"address"},{"internalType":"int24","name":"tickLower","type":"int24"},{"internalType":"int24","name":"tickUpper","type":"int24"}],"stateMutability":"nonpayable","type":"function","name":"openInitialPosition","outputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint128","name":"liquidity","type":"uint128"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"pool","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[{"internalType":"address","name":"vault","type":"address"},{"internalType":"int24","name":"tickLower","type":"int24"},{"internalType":"int24","name":"tickUpper","type":"int24"},{"internalType":"uint256","name":"cap0","type":"uint256"},{"internalType":"uint256","name":"cap1","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"rebalanceWithCaps","outputs":[{"internalType":"uint128","name":"newLiquidity","type":"uint128"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"slot0","outputs":[{"internalType":"uint160","name":"sqrtPriceX96","type":"uint160"},{"internalType":"int24","name":"tick","type":"int24"}]},{"inputs":[{"internalType":"address","name":"vault","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"stakePosition"},{"inputs":[],"stateMutability":"view","type":"function","name":"tickSpacing","outputs":[{"internalType":"int24","name":"","type":"int24"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"tokens","outputs":[{"internalType":"address","name":"token0","type":"address"},{"internalType":"address","name":"token1","type":"address"}]},{"inputs":[{"internalType":"address","name":"vault","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"unstakePosition"}],"devdoc":{"kind":"dev","methods":{"claimRewards(address)":{"details":"Implementations that cannot deliver rewards directly to the vault MAY      route rewards through the adapter and then forward them to the vault.","params":{"vault":"Vault address whose rewards will be claimed."}},"collectToVault(address)":{"params":{"vault":"Vault address whose position fees will be collected."},"returns":{"amount0":"Amount of token0 sent to the vault.","amount1":"Amount of token1 sent to the vault."}},"currentTokenId(address)":{"params":{"vault":"Vault address owning the position."}},"exitPositionToVault(address)":{"details":"- Typical implementation:     * Collect fees.     * Decrease all liquidity, collect owed tokens.     * Burn the NFT.     * Transfer all token0/token1 balances held by the adapter for this position back to the vault. - If there is no position for the vault, this function SHOULD simply return.","params":{"vault":"Vault address whose position will be closed."}},"gauge()":{"details":"May be zero address if no staking is used."},"openInitialPosition(address,int24,int24)":{"details":"- The adapter is expected to:     * Read token0/token1 balances from the vault.     * Transfer those tokens into the adapter.     * Mint an LP NFT and keep it under the adapter.     * Return any unused tokens back to the vault. - Implementations MAY assume the vault has `approve`d this adapter   to pull tokens through ERC-20 `transferFrom`.","params":{"tickLower":"Lower bound of the price range.","tickUpper":"Upper bound of the price range.","vault":"Vault address on behalf of which the position is opened."},"returns":{"liquidity":"Final liquidity amount for the minted position.","tokenId":"Newly created LP NFT id."}},"rebalanceWithCaps(address,int24,int24,uint256,uint256)":{"details":"- Typical implementation:     * Collect fees to the adapter.     * Decrease liquidity fully and collect owed tokens.     * Burn the old NFT.     * Optionally pull more token0/token1 from the vault up to (cap0, cap1).     * Mint a new position in the new range, returning unused tokens to the vault.","params":{"cap0":"Maximum additional token0 to pull from the vault (0 = no limit / use all).","cap1":"Maximum additional token1 to pull from the vault (0 = no limit / use all).","tickLower":"New lower bound of the price range.","tickUpper":"New upper bound of the price range.","vault":"Vault address whose position will be rebalanced."},"returns":{"newLiquidity":"Liquidity of the newly minted position."}},"stakePosition(address)":{"details":"If `gauge()` is zero address, implementation MAY simply return.","params":{"vault":"Vault address whose position will be staked."}},"unstakePosition(address)":{"details":"If `gauge()` is zero address, implementation MAY simply return.","params":{"vault":"Vault address whose position will be unstaked."}}},"version":1},"userdoc":{"kind":"user","methods":{"claimRewards(address)":{"notice":"Claim staking rewards for a vault's position and forward them to the vault."},"collectToVault(address)":{"notice":"Collect outstanding pool fees for a vault's position and push them to the vault."},"currentTokenId(address)":{"notice":"Returns the current LP NFT id (if any) assigned to a given vault."},"exitPositionToVault(address)":{"notice":"Exit the current position for a vault and return all tokens to the vault."},"gauge()":{"notice":"Returns the gauge / staking contract address (if any)."},"nfpm()":{"notice":"Returns the Non-Fungible Position Manager address (NFT LP manager)."},"openInitialPosition(address,int24,int24)":{"notice":"Open an initial concentrated-liquidity position for a vault."},"pool()":{"notice":"Returns the underlying CL pool address."},"rebalanceWithCaps(address,int24,int24,uint256,uint256)":{"notice":"Rebalance an existing position for a vault with upper caps for additional capital."},"slot0()":{"notice":"Returns current pool price info (sqrtPriceX96, tick)."},"stakePosition(address)":{"notice":"Stake the vault's LP NFT into the gauge / MasterChef (if any)."},"tickSpacing()":{"notice":"Returns the pool tick spacing."},"tokens()":{"notice":"Returns the underlying token pair (token0, token1) for the pool."},"unstakePosition(address)":{"notice":"Unstake the LP NFT from the gauge / MasterChef (if any)."}},"version":1}},"settings":{"remappings":["@openzeppelin/=lib/openzeppelin-contracts/","@uniswap/swap-router-contracts/=lib/swap-router-contracts/","@uniswap/v3-core/=lib/v3-core/","@uniswap/v3-periphery/=lib/v3-periphery/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","swap-router-contracts/=lib/swap-router-contracts/contracts/","v3-core/=lib/v3-core/","v3-periphery/=lib/v3-periphery/contracts/"],"optimizer":{"enabled":true,"runs":1000000},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"src/interfaces/IConcentratedLiquidityAdapter.sol":"IConcentratedLiquidityAdapter"},"evmVersion":"paris","libraries":{},"viaIR":true},"sources":{"src/interfaces/IConcentratedLiquidityAdapter.sol":{"keccak256":"0x11a9be76965d03cfde84421a01e9525e68beeb0eacb091167e1e16a7408e1924","urls":["bzz-raw://34c299c8582cff6c0bd94366070a269b52f00a8cbe650a862b307d41490a39bf","dweb:/ipfs/QmQnza3LZKZRpk85tgdYyUvhJryxm2yFJGkPtaHkRCjDMY"],"license":"MIT"}},"version":1},"id":90}